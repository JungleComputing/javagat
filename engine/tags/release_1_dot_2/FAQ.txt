Q: What is the difference between DataBrowsingFileAdaptor and DataMovementFileAdaptor?

A:
Good question! They are both File adaptors. Because the Java GAT has
dynamic binding, an adaptor does not have to implement the full
functionality of the GAT object API. So basically, DataMovement
interfaces to the gridlab data service, while DataBrowsing interfaces
to the gridlab data browsing service. Currently, WP-8 implemented
those as two different services (they will be merged at some point I
heard).

So together, the two adaptors implement remote files, but they can be
used seperately. In the latter case, some methods will not work,
others will. So if you have only DataMovement, File.copy will work,
but File.getSize() throws an exception...


Q: Why is there a split DefaultFileInputStreamAdaptor and DefaultFileOutputStreamAdaptor?

A: 
OK, these are indeed seperate objects in the Java GAT. We chose to do
that, because it is like that in normal Java, and because this way all
Java's IO code can be reused. The streams extend java.io.InputStream
and OutputStream. So this way you can use Java serialization, RMI,
etc. with the GAT.


Q: What of DefaultRandomAccessFileAdaptor?

A:
OK, that is something that is completely missing in the GAT. It is
sort of scheduled for the GAT API 2.0 I think, but the Java GAT
already has it... Again, it is compatible with the java.io.*
classes...  In the current GAT API spec, you can seek in streams. The
idea is to seperate the streaming and random access access to files.

So, to summarize, the Java GAT File API is slightly different that
what the API spec prescribes. Two reasons for that:

1. Fits better in Java (compatible with java.io.*)
2. The next GAT spec will probably look similar to this anyway.


Q: Why doesn't my application terminate?
A: Did you call GAT.end() ?
   if you didn't -> call it please :-)
   if you did -> press CTRL - \ to let the JVM dump all stacks.
   If you think that the cause is GAT, send me a bug report containing the
   stack traces.


Q: If I try to copy: file:////test.txt -> ssh://mleyton@machine/test.txt
   When GAT looks for adaptors, no one fits. On the other hand this works:
   any:///test.txt -> ssh://mleyton@machine/test.txt
   Why does this happen?
A: For the copy this means that the copy method is executed by the
   adaptor of the SRC file object, since you call SRC.copy(DEST).  So
   this adaptor that has to do the copying is an adaptor that speaks the
   protocol of the SRC file.  Thus, something like file://XXX ->
   ssh://YYY does not work, because the adator that implements the "file"
   protocol does not speak ssh.  any://XXX -> SCHEME://YYY should work,
   regardless of SCHEME.

Q: Shouldn't the late binding jump in in the above case and select
   another adaptor on the copy operation?

A: Not if the file object explicitely defines a scheme in the URI.  So
   if you create a file with the URI
   gsiftp://fs0.das2.cs.vu.nl//home/rob/foo Than the GAT engine cannot
   use a local file adaptor or the ssh adaptor.  It does not make sense,
   the user said it should be gsiftp...  If you want this, you should
   use the "any" scheme: any://fs0.das2.cs.vu.nl//home/rob/foo


Q: I get an error saying "GAT: No adaptors could be loaded" when I run without the run_gat_app script

A: You can point the place where the adaptors are located out to the
engine with the -Dgat.adaptor.path=XXX:YYY:ZZZ commandline option,
where XXX, YYY and ZZZ are directories that contain .jar files. You
don't have to mention the individual jars, just put the directory
where they live in the adaptor path. The "external" jars directory
from the "external" directory of the JavaGATAdaptors should also be in
the adaptor path...  There is no need to put the adaptor jars in the
classpath. 

Have Fun,

Rob
