package org.gridlab.gat.resources.cpi.proactive;

import java.io.Serializable;
import java.util.HashMap;

import org.apache.log4j.Logger;
import org.objectweb.proactive.Body;
import org.objectweb.proactive.RunActive;
import org.objectweb.proactive.Service;
import org.objectweb.proactive.core.node.Node;
import org.objectweb.proactive.core.process.JVMProcessImpl;
import org.objectweb.proactive.core.process.AbstractExternalProcess.StandardOutputMessageLogger;
import org.objectweb.proactive.core.util.wrapper.StringWrapper;

/**
 * This class takes care of launching JVMs to execute the application.
 * Each node runs an instance of this class.
 * It must be public, otherwise the stub generated by ProActive cannot
 * access it.
 */
public class Launcher implements Serializable, RunActive {
    /** Maps job id's to jvms. */
    private HashMap jobs = new HashMap();

    /** For debugging and error messages. */
    private static final Logger logger
            = ibis.util.GetLogger.getLogger(Launcher.class);

    /** For making callbacks to maintain job administration. */
    final JobWatcher jobWatcher;

    /** Node on which this launcher is running. */
    final Node node;

    /**
     * Every time an application JVM is started, an accompanying thread
     * is started to keep track of its status.
     */
    class Watcher extends Thread {
        /** The JVM. */
        JVMProcessImpl jvm;

        /** The identification of the job. */
        String jobID;

        /** Instance number for this job. */
        int instanceNo;

        /**
         * Constructor, with specified initial values for the fields.
         * @param jvm the JVM.
         * @param jobID the job identification.
         * @param instanceNo instance number of this job.
         */
        public Watcher(JVMProcessImpl jvm, String jobID, int instanceNo) {
            this.jvm = jvm;
            this.jobID = jobID;
            this.instanceNo = instanceNo;
            setDaemon(true);
            start();
        }

        /**
         * Waits until the JVM is finished, and notifies the watcher.
         */
        public void run() {
            while (! jvm.isFinished()) {
                try {
                    jvm.waitFor();
                } catch(Exception e) {
                    // ignored
                }
            }

            jobWatcher.finishedJob(jobID, instanceNo, jvm.exitValue());
        }
    }

    /**
     * Public noargs constructor, required by ProActive.
     */
    public Launcher() {
        jobWatcher = null;
        node = null;
    }

    /**
     * Constructor with specified watcher on the specified node.
     * @param jobWatcher the watcher to notify.
     */
    public Launcher(JobWatcher jobWatcher, Node node) {
        this.jobWatcher = jobWatcher;
        this.node = node;
    }

    /**
     * ProActive activity handler.
     * @param body the active body.
     */
    public void runActivity(Body body) {
        Service service = new Service(body);

        while (body.isAlive() && body.isActive()) {
            service.blockingServeOldest();
            logger.info("Served request");
        }
        logger.info("runActivity terminates");
    }

    /**
     * Launches a new JVM for the application specified in the parameters.
     * It returns a StringWrapper, to allow for asynchronous launch.
     * For that to work, the return class type may not be final.
     * @param classname the name of the class to run.
     * @param jvmArgs JVM parameters.
     * @param progArgs application arguments.
     * @param classpath the classpath.
     * @param jobID identification for this job.
     * @param instanceNo the instance number of this job.
     * @return a string wrapper containing the job id or <code>null</code>
     * in case of failure.
     */
    public StringWrapper launch(String classname, String jvmArgs,
            String progArgs, String classpath, String jobID, int instanceNo) {

        // Create the JVM process and set its parameters.
        JVMProcessImpl jvm = new JVMProcessImpl(
                new StandardOutputMessageLogger(),
                new StandardOutputMessageLogger());

        jvm.setClassname(classname);

        jvm.setLog4jFile(null);
        jvm.setPolicyFile(null);

        if (classpath != null) {
            jvm.setClasspath(classpath);
        }

        jvm.setParameters(progArgs);

        jvm.setJvmOptions(jvmArgs);

        // Try and run it, spawn watcher thread if this succeeds.
        try {
            node.getProActiveRuntime().createVM(jvm);
            //jvm.startProcess();
            synchronized(jobs) {
                jobs.put(jobID, jvm);
            }

            jobWatcher.startedJob(jobID);
            new Watcher(jvm, jobID, instanceNo);
        } catch (Exception e) {
            logger.warn("Got exception during createVM:",  e);
            return new StringWrapper(null);
        }
        return new StringWrapper(jobID);
    }

    /**
     * Stops the specified job if present.
     * @param id the job identification.
     */
    public void stopJob(String id) {
        JVMProcessImpl jvm;
        synchronized(jobs) {
            jvm = (JVMProcessImpl) jobs.get(id);
        }
        if (jvm != null) {
            jvm.stopProcess();
        }
    }

    /**
     * Test method. Returns an int, so is synchronous.
     * @return 0.
     */
    public int ping() {
        return 0;
    }
}
